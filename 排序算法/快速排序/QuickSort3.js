/*
  双路排序算法
  优化当数组内有大量重复元素会降低性能
  双路快速排序法
  partition思路：仍然是随机取一个元素，与第一个元素替换，
  i从左开始(l+1)，j从右开始，i以及i左边存放的是小于第一个元素的元素，j以及j右边存放的是大于第一个元素的元素，
  假设第一个数是v，
  当arr[i]<v,i++,当arr[i]>=v时，停住，转而去j--，直到arr[j]<=v,arr[i]与arr[j]交换元素，然后i++,j--继续这个步骤
  这样就可以将相同的元素平均的分散到数组的两边，防止了堆在一边的情况
  循环不变量:arr[l+1,i-1]<=v    arr[j+1,r]>=v     i永远指向的是还没有比较的元素

  第一层while因为不确定循环次数并且在左右两侧分别循环后需要继续循环，
  第二层while就是控制i和j
*/
function partition(arr, l, r) {
  let p = parseInt(Math.random() * (r - l)) + l
  swap(arr, p, l)

  //循环不变量:arr[l+1,i-1]<=v    arr[j+1,r]>=v,
  //j是标定点，就是被比较的那个元素，最后返回的也是j
  let i = l + 1,
    j = r
  while (true) {
    //i <= j保证数组中还有元素没有被比较
    while (i <= j && arr[i] < arr[l]) {
      i++
    }
    while (j >= i && arr[j] > arr[l]) {
      j--
    }
    /**
     * 到这里的时候就表示i和j都停住了，i遇到了大于等于标定点的元素，j遇到了小于等于标定点的元素
     i>j表示数组内所有元素已经都和标定点对比过了
     i===j表示已经循环到了最后一个元素了，并且这个元素和标定点是相同的
     当i和j在同一个位置停下就表示这个元素和标定点相同
     */
    if (i >= j) {
      break
    }
    swap(arr, i, j)
    i++
    j--
  }
  swap(arr, l, j)
  return j
}
